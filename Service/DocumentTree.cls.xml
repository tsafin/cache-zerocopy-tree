<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Service.DocumentTree">
<Description>
Experimental class to support connected tree forest</Description>
<IncludeCode>Service.DocTreeDefault</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64169,63548.890846</TimeCreated>

<Property name="TempGlo">
<Description>
By default uses @TempGlo PPG storage or the whole forest (i.e. it's redirected to CACHETEMP)
You could use any local or global for those purposes</Description>
<Type>%String</Type>
<InitialExpression>$$$DOCTREEDEFAULT</InitialExpression>
</Property>

<Property name="AutoCleanup">
<Description>
Cleanup all created trees upon object closure</Description>
<Type>%Boolean</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="KnownTrees">
<Description>
Root pointers for all known so far named trees,
i.e. for $this.DocumentContent it would be i%KnownTrees("DocumentContent") pointing to 
the ..TempGlo subtree </Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="XlatedSubsCache">
<Description>
cache of recently translated/walked subscripts
might point to differennt global altogether
TODO - limit cache size to N recentmost walks</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="KeepObjects">
<Description>
we need to keep opened [and their storage retained]
all zerocopy objects we were merged with. 
So keep object handy, increasing their reference counters</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ..AutoCleanup {
		#dim trees As %String = $order(..KnownTrees(""))
		while trees '= "" {
			set next = $order(..KnownTrees(trees))
			kill @..CalcTreeGloRef(..KnownTrees(trees))
			set trees = next
		}
		// NB! ..KeepObjects(*) array will be cleaned up automatically
		// and their objects temp trees will be removed upon all reference closed
	}
	return $$$OK
]]></Implementation>
</Method>

<Method name="ReserveTree">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim gloRef As %String = ..TempGlo
	#dim i As %integer = $Increment(@gloRef)
	
	return $name(@gloRef@(i))
]]></Implementation>
</Method>

<Method name="AddTree">
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// i.e. for DocumentContent we will have root node incremented
	// ^||DocTree = 1
	// and gloref pointer saved to KnownTrees array
	// i%KnownTrees("DocumentContent") => ^||DocTree(1)
	
	#dim gloRef As %String = ..ReserveTree()
	set ..KnownTrees(Name) = gloRef
	return gloRef
]]></Implementation>
</Method>

<Method name="DumpTree">
<FormalSpec>Name:%String</FormalSpec>
<Implementation><![CDATA[
	#dim gloRef As %String = $get(..KnownTrees(Name))
	if gloRef '= "" {
		zwrite @gloRef
	}
]]></Implementation>
</Method>

<Method name="PurgeAllTrees">
<ClassMethod>1</ClassMethod>
<FormalSpec>TempGlo:%String=$$$DOCTREEDEFAULT</FormalSpec>
<Implementation><![CDATA[	kill @TempGlo
]]></Implementation>
</Method>

<Method name="CalcTreeGloRef">
<FormalSpec><![CDATA[TreeGloRef:%String="",&encodedSubs:%List,Args...]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// nothing to start from, bail out
	if TreeGloRef = "" {
		return ""
	}
	#dim i As %Integer
	// TODO - extract to walk() function
	// convert args to proper subscripts syntax, 
	// calculate their encoded hash string along a way
	for i=1:1:$get(Args) {
		set TreeGloRef = $name(@TreeGloRef@(Args(i)))
		set encodedSubs = encodedSubs _ $lb(Args(i)) // TODO - encode using NLS normalization via $zu(70,*)
	}

	return TreeGloRef
]]></Implementation>
</Method>

<Method name="RetainObjectsRef">
<Description>
increment reference to the object to make sure it will be kept
around till our own closure</Description>
<FormalSpec>Value:%RegisteredObject</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	#dim stringified As %String = ""_Value
	if '$get(..KeepObjects(stringified)) {
		set ..KeepObjects($increment(..KeepObjects)) = Value
		set ..KeepObjects(stringified) = 1
	}
]]></Implementation>
</Method>

<Method name="Assign">
<Description>
Assign value (scalar or object) to the multi-dimensional node @GloRef</Description>
<FormalSpec>GloRef:%String,Value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$isobject(Value) {
		set @GloRef = Value
	} else {
		do ..RetainObjectsRef(Value)

		#dim name As %String = Value.DocTreeName
		#dim object As DocumentTree = Value.TreeObject
		set @GloRef = object.CalcTreeGloRef($get(object.KnownTrees(name)))
	}
]]></Implementation>
</Method>

<Method name="GloRef">
<FormalSpec>Property:%String</FormalSpec>
<Implementation><![CDATA[
	#dim ptr As TreeHolder = ##class(TreeHolder).%New()
	// no extra arguments, access to the root
	set ptr.TreeObject = $this
	set ptr.DocTreeName = Property
#if 0
	if $get(Args) > 0 {
		// TODO
	}
#endif
	return ptr
]]></Implementation>
</Method>

<Method name="GetMultiArray">
<Description>
Getter for unknown multidimensional property (i.e. DocumentContent)
silently invokes tree walker</Description>
<FormalSpec>Property:%String,OffsetSubs:%String="",Args...</FormalSpec>
<Implementation><![CDATA[
	#dim gloRef As %String = $get(..KnownTrees(Property))
	#dim encodedSubs = ""

	if gloRef '= "" {
		set gloRef = ..CalcTreeGloRef(gloRef, .encodedSubs, Args...)
		if OffsetSubs '= "" {
			set gloRef = $name(@gloRef@(OffsetSubs))
		}
		return $get(@gloRef)
	} else {
		return ""
	}
]]></Implementation>
</Method>

<Method name="%DispatchMethod">
<FormalSpec>Method:%String,Args...</FormalSpec>
<Implementation><![CDATA[	return ..GetMultiArray(Method, "", Args...)
]]></Implementation>
</Method>

<Method name="SetMultiArray">
<Description>
Setter for unknown multidimensional property</Description>
<FormalSpec>Property:%String,OffsetSubs:%String="",Val,Subs...</FormalSpec>
<Implementation><![CDATA[
	#dim gloRef As %String = $get(..KnownTrees(Property))
	if gloRef = "" {
		set gloRef = ..AddTree(Property)
	}
	if OffsetSubs '= "" {
		set gloRef = $name(@gloRef@(OffsetSubs))
	}
	#dim encodedSubs As %List = ""

	if gloRef '= "" {
		set gloRef = ..CalcTreeGloRef(gloRef, .encodedSubs, Subs...)
		do ..Assign(gloRef, Val)
	}
]]></Implementation>
</Method>

<Method name="%DispatchSetMultidimProperty">
<FormalSpec>Property:%String,Val,Subs...</FormalSpec>
<Implementation><![CDATA[	do ..SetMultiArray(Property, "", Val, Subs...)
]]></Implementation>
</Method>

<Method name="Debug">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	set d = ##class(DocumentTree).%New()
	set d.DocTree(1) = 13
	set d.DocTree(1,1) = 1
	set d.DocTree(1,3) = 3
	zw d
	do d.DumpTree("DocTree")
	
	set k = ##class(DocumentTree).%New()
	set k.DocTree(2) = 26
	set k.DocTree(2,2) = 2
	zw k
	do k.DumpTree("DocTree")

	write !, "Assignment d(2) = k",!	
	set d.DocTree(2) = k.GloRef("DocTree")
	zw d
	do d.DumpTree("DocTree")
	write ! zw k
]]></Implementation>
</Method>
</Class>
</Export>
