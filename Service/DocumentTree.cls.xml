<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Service.DocumentTree">
<Description>
Experimental class to support connected tree forest</Description>
<IncludeCode>Service.DocTreeDefault</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64169,63548.890846</TimeCreated>

<Property name="TempGlo">
<Description>
By default uses @TempGlo PPG storage or the whole forest (i.e. it's redirected to CACHETEMP)
You could use any local or global for those purposes</Description>
<Type>%String</Type>
<InitialExpression>$$$DOCTREEDEFAULT</InitialExpression>
</Property>

<Property name="AutoCleanup">
<Description>
Cleanup all created trees upon object closure</Description>
<Type>%Boolean</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="KnownTrees">
<Description>
Root pointers for all known so far named trees,
i.e. for $this.DocumentContent it would be i%KnownTrees("DocumentContent") pointing to 
the ..TempGlo subtree </Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="XlatedSubsCache">
<Description>
cache of recently translated/walked subscripts
might point to differennt global altogether
TODO - limit cache size to N recentmost walks</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ..AutoCleanup {
		#dim trees As %String = $order(..KnownTrees(""))
		while trees '= "" {
			set next = $order(..KnownTrees(trees))
			kill @..CalcTreeGloRef(..KnownTrees(trees))
			set trees = next
		}
	}
	return $$$OK
]]></Implementation>
</Method>

<Method name="ReserveTree">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim gloRef As %String = ..TempGlo
	#dim i As %integer = $Increment(@gloRef)
	
	return $name(@gloRef@(i))
]]></Implementation>
</Method>

<Method name="AddTree">
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// i.e. for DocumentContent we will have root node incremented
	// ^||DocTree = 1
	// and gloref pointer saved to KnownTrees array
	// i%KnownTrees("DocumentContent") => ^||DocTree(1)
	
	#dim gloRef As %String = ..ReserveTree()
	set ..KnownTrees(Name) = gloRef
	return gloRef
]]></Implementation>
</Method>

<Method name="DumpTree">
<FormalSpec>Name:%String</FormalSpec>
<Implementation><![CDATA[
	#dim gloRef As %String = $get(..KnownTrees(Name))
	if gloRef '= "" {
		zwrite @gloRef
	}
]]></Implementation>
</Method>

<Method name="PurgeAllTrees">
<ClassMethod>1</ClassMethod>
<FormalSpec>TempGlo:%String=$$$DOCTREEDEFAULT</FormalSpec>
<Implementation><![CDATA[	kill @TempGlo
]]></Implementation>
</Method>

<Method name="CalcTreeGloRef">
<FormalSpec><![CDATA[TreeGloRef:%String="",&encoded,Args...]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// nothing to start from, bail out
	if TreeGloRef = "" {
		return ""
	}
	#dim i As %Integer
	#dim encodedSubs As %List = ""
	// TODO - extract to walk() function
	// convert args to proper subscripts syntax, 
	// calculate their encoded hash string along a way
	for i=1:1:$get(Args) {
		set TreeGloRef = $name(@TreeGloRef@(Args(i)))
		set encodedSubs = encodedSubs _ $lb(Args(i)) // TODO - encode using NLS normalization via $zu(70,*)
	}

	return TreeGloRef
]]></Implementation>
</Method>

<Method name="%DispatchMethod">
<Description>
Getter for unknown multidimensional property (i.e. DocumentContent)
silently invokes tree walker</Description>
<FormalSpec>Method:%String,Args...</FormalSpec>
<Implementation><![CDATA[
	#dim gloRef As %String = $get(..KnownTrees(Method))
	#dim encodedSubs = ""

	if gloRef '= "" {
		set gloRef = ..CalcTreeGloRef(gloRef, .encodedSubs,Args...)
		return $get(@gloRef)
	} else {
		return ""
	}
]]></Implementation>
</Method>

<Method name="Assign">
<Description>
Assign value (scalar or object) to the multi-dimensional node @GloRef</Description>
<FormalSpec>GloRef:%String,Value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$isobject(Value) {
		set @GloRef = Value
	} else {
		// TODO
	}
]]></Implementation>
</Method>

<Method name="%DispatchSetMultidimProperty">
<Description>
Setter for unknown multidimensional property</Description>
<FormalSpec>Property:%String,Val,Subs...</FormalSpec>
<Implementation><![CDATA[
	#dim gloRef As %String = $get(..KnownTrees(Property))
	if gloRef = "" {
		set gloRef = ..AddTree(Property)
	}
	#dim encodedSubs As %List = ""

	if gloRef '= "" {
		set gloRef = ..CalcTreeGloRef(gloRef, .encodedSubs, Subs...)
		do ..Assign(gloRef, Val)
	}
]]></Implementation>
</Method>
</Class>
</Export>
